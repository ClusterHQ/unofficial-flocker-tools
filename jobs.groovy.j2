// vim: ai ts=2 sts=2 et sw=2 ft=jinja fdm=indent et
{# jobs.groovy.j2

  This jinja2 template is used to produce a jobs.groovy file containing the
  jenkins job DSL plugin code to build all the required views, folders, and
  jobs for a particular project in the Jenkins interface.

   The full Jenkins job DSL reference can be found on the URL below:
   https://github.com/jenkinsci/job-dsl-plugin/wiki/Job-reference

   The file is consumed by the Jenkins job setup_ClusterHQ_UFT. That job
   contains two build steps, the first executes a python file 'render.py' which
   reads the build.yaml file and expands this jobs.groovy.j2 template using
   the contents of that yaml dictionary. The resulting jobs.groovy file is then
   read by a second build step of type 'Process Job DSL' which produces all
   the jenkins objects.

   A typical jenkins job contains the following sections, this is just an
   example of possible actions within a particular section:

   * Parameters:
        - parameters can be added to a job, these are used to pass environment
          variables to the build steps or any other step in the job.

   * Source Control defintions:
        - repository URL
        - what SCM tool git/svn/mercurial
        - operations to do prior/after a git update/close

    * Triggers:
        - When to execute the build ?
        - On a crontab style
        - by pooling the repository for changes
        - triggered by GitHub or others

   * Wrappers which 'decorate' the build steps of the job
        - adds stuff like timestamps to the log output
        - sets a timeout and aborts the build when exceeded

    * Build steps
        - Commonly shell based steps, as in the cli to execute

    * Post-Build actions also called Publishers:
        - Archiving produced files so that they are made available in other
          jobs
        - Running coverage or test reports
        - Triggering other jobs


    The structure of this jinja2 file is as follows:

    A set of Jinja2 macro definitions which produce job dsl text for the
    different sections of the job:
        - folder (creates a folder view in Jenkins to store the jobs)
        - wrappers
        - triggers
        - scm (sets the Source Control section)
        - publishers (set the post-build steps)
        - steps (consumes the contentes of the build.yaml build steps, and
            expands those as shell cli text'

    The last section in this file is a definition block for cron style job
    type jobs which are not executed as part of the main multijob.
    These follow a similar structure to the common 'job_type' definitions
    above, except they include a trigger section specifying an daily schedulle.
#}

{# ------------------------------------------------------------------------- #}
{# JINJA2 MACROS DEFINED BELOW                                               #}
{# --------------------------------------------------------------------------#}

{% macro folder(folder, display_name)                                       -%}
{# creates a folder structure to group jobs, these are the Jenkins folder views
   in the Jenkins UI.

   param folder:  '<clusterhq-unnoficial-flocker-tools/branchname>'
   param displayName: Name displayed in the jenkins view for this folder     #}

println("creating {{folder}}...")
folder("{{folder}}") { displayName("{{display_name}}") }
{%- endmacro                                                                -%}


{% macro wrappers(v, directory_to_delete)                                   -%}
{# adds a list of common wrappers to the build jobs.

   param v:  dictionary containing the values from the job
   param directory_to_delete: directory to clean up
#}
    wrappers {
{#    adds timestamps to the job log output                                  #}
      timestamps()
{#    colorizeOuptut allows for ascii coloured output in the logs of a job   #}
      colorizeOutput()
{#    define the max duration a running job should take, this prevents stuck
      jobs for reserving jenkins slaves and preventing other jobs from running.
      These timeouts will have to be adjusted as we work on improving the
      execution time of the tests so that we can enforce a SLA of a maximum of
      'n' minutes.
      An improvement here (TODO) would be to receibe the timeout as a parameter
      so that we can have different timeouts for different job types.        #}
      timeout {
          absolute({{v.timeout}})
          failBuild()
      }
    }
{%- endmacro                                                                -%}


{% macro triggers(_type, _value, _branch )                                 -%}
{# adds a list of triggers to the build job

   param  _type: type of job
   _value: the cron string

#}
    triggers {
{#  the job_type 'cron' is used by the docker_build jobs running every 24h
    but we only configure the scheduler if the jobs is for the master branch.
    If we were to schedule the job on every branch we would have multiple jobs
    running at the same time                                                 #}
        if ("{{_type}}" == "cron" && "{{_branch}}" == "master") {
{#  the cron  string below is a common crontab style string                  #}
            cron("{{_value}}")
        }
{#  the job_type 'githubPush' is used by the multijob, we use it to
    configure that job so that builds on master are triggered automatically
    this block enables 'Build when a change is pushed to GitHub'
#}
        if ("{{_type}}" == "githubPush" && "{{_branch}}" == "master") {
            configure { node ->
                node / 'triggers' / 'com.cloudbees.jenkins.GitHubPushTrigger' {
                spec ''
                }
            }
        }
    }
{%- endmacro                                                                -%}


{% macro scm(git_url, branch) -%}
{# configures a remote git repository, and merges 'branch' before build

    param: git_url - example: https://github.com/clusterhq/unnoficial-flocker-tools
    param: branch - remote branch name to configure
#}
    scm {
      git {
        remote {
{#  our remote will be called 'upstream'                                     #}
          name("upstream")
{#  the project name from the build yaml 'ClusterHQ/unnoficial-flocker-tools'#}
          github("{{cfg.project}}")
        }
{#  configure the git user merging the branches.
    the job dsl scm/git doesn't contain a method to specify the local git user
    or email address, so we use a configure/node block to insert the XML block
    into the jenkins job config
#}
        configure { node ->
            node / gitConfigName('Jenkins')
            node / gitConfigEmail('jenkins@clusterhq.com')
        }
{#  the branch to be built                                                   #}
        branch("{{branch}}")
{#  clean the repository before merging (git reset --hard)                   #}
        clean(true)
        createTag(false)
{#  merge our branch with the master branch                                  #}
        mergeOptions {
            remote('upstream')
            branch('master')
{#  there are a few merge strategies available, recursive is the default one #}
            strategy('recursive')
        }
      }
    }
{%- endmacro                                                                -%}


{% macro publishers(v)                                                      -%}
{# adds a publishers block to the jenkins job configuration, containing:
   an action for archiving artifacts
   an action for archiving junit results
   an action for publishing coverate reports

   param v: dictionary containing the job keys
#}
    publishers {
    }
{%- endmacro                                                                -%}


{% macro steps(v)                                                           -%}
{#  builds a list of job steps based on the type of the job:
    ( 'shell', others )
    currently only shell has been implemented.

    params v: dictionary containing the job values                           #}
    steps {
{%  for _step in v                                                          -%}
{%    if _step.type=='shell'                                                 %}
    shell("""
{%      for line in _step.cli                                               -%}
      {{ line }}
{%      endfor                                                              -%}
    """)
{%    endif                                                                 -%}
{%  endfor                                                                   %}
    }
{%- endmacro                                                                -%}


{# groov lacks a loop...until ...                                            #}
class Looper {
   private Closure code

   static Looper loop( Closure code ) {
      new Looper(code:code)
   }

   void until( Closure test ) {
      code()
      while (!test()) {
         code()
      }
   }
}

{#  the project name from the build yaml 'ClusterHQ/Unnoficial-flocker-tools'#}
def project = "{{ cfg.project }}"
{#  the github https url for the project                                     #}
def git_url = "{{ cfg.git_url }}"

{# Lets's call it ClusterHQ-UFT instead of ClusterHQ/...                     #}
def dashProject = "{{ cfg.project }}".replace('/', '-')

{# Create a basefolder for our project, it should look like:
   '<github username>-<git repository>'                                      #}
{{ folder("${dashProject}","${dashProject}") }}

{# branchName contains the passed parameter RECONFIGURE_BRANCH from jenkins  #}
{#  swap '/' with '-'                                                        #}
  branchName = "${RECONFIGURE_BRANCH}"
  dashBranchName = "${branchName}".replace("/","-")

{# create a folder for every branch: /git-username/git-repo/branch           #}
  {{ folder("${dashProject}/${dashBranchName}","${branchName}") }}


{# ------------------------------------------------------------------------- #}
{# CRON JOBS BELOW                                                           #}
{# --------------------------------------------------------------------------#}

{# Configure cronly jobs, these are not part of the main branches loop       #}
{# As we only run them from the master branch, they get executed a few       #}
{# times a day based on a cron type schedule.                                #}

{% for job_type, job_type_values  in cfg.job_type.iteritems()               -%}
{%  for job_name, job_values  in job_type_values.iteritems()                -%}

{# apply config related to 'cronly_jobs' jobs                                #}
{%    if job_type == 'cronly_jobs'                                          -%}
{%        set _job_name = job_name                                          -%}
  job("${dashProject}/${branchName}/_{{ _job_name }}") {
    parameters {
        textParam("TRIGGERED_BRANCH", "${branchName}", "Branch that triggered this job" )
    }
    label("{{ job_values.on_nodes_with_labels }}")
    {{ wrappers(job_values, 'none') }}
    {{ triggers('cron', job_values.at, "${branchName}") }}
    {{ scm("${git_url}", "${branchName}") }}
    {{ steps(job_values.with_steps) }}
  }
{%    endif                                                                  %}
{%  endfor                                                                   %}
{% endfor                                                                    %}
